## 1. 存储引擎
### 1.1 MySQL 体系结构

![1](..\assets\day02\1.png)

* 连接层：主要完成连接处理、授权认证以及安全相关方案。
* 服务层：完成大多数的核心服务功能，如 SQL 接口，SQL 的解析和优化...
* 引擎层：真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信
* 存储层：将数据（redolog、数据、索引、日志等等）存储在文件系统上，并完成与存储引擎的交互

MySQL 与其他数据库相比，优势在于插件式存储引擎结构，将查询处理和数据存储提取分离，这种架构可以根据业务的需求选择合适的存储引擎。



### 1.2 存储引擎介绍

存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，所以在创建表的时候，可以指定存储引擎

```sql
# 建表时指定存储引擎
create table 表名(
	字段1 类型 [comment 注释],
    字段2 类型 [comment 注释],
    ......
    字段n 类型 [comment 注释]
)engine = innodb [comment 表注释];

# 查询当前数据库支持的存储引擎
show engines;

# 查询建表语句——查看存储引擎
show create table account;

```

### 1.3 存储引擎的特定

#### InnoDB

InnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的  MySQL 存储引擎。

它具有的特点（区别于其他的存储引擎）：

* 支持事务
* 行级锁，提高并发访问性能
* 支持外键 foreign key 约束

InnoDB 的每张表都对应一个基于二进制存储的 表名.idb 表空间文件，存储该表的表结构、数据和索引。

InnoDB 的逻辑存储结构如下：

![2](..\assets\day02\2.png)

* 表空间 : InnoDB 存储引擎逻辑结构的最高层，ibd 文件其实就是表空间文件
* 段 : 表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。用户感知不到段的存在，其管理是由引擎自身完成的。
* 区 : 区是表空间的单元结构，每个区的大小为1M，InnoDB存储引擎页大小为 16K， 即一个区中一共有64个连续的页。 
* 页 : 页是组成区的最小单元，页也是 InnoDB 存储引擎磁盘管理的最小单元（意味着 InnoDB 以页作为与磁盘进行 I/O 的最小逻辑单位，而不是按单条记录读写），每个页的大小默 认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。
*  行 : InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时所指定的字段以外，还包含两个隐藏字段。

---------

## 2. 索引

### 2.1 索引概述

索引（index）是帮助 MySQL 高效获取数据的数据结构(有序)。意味着，除了数据，数据库系统还维护了索引这个数据结构，它以某种方式引用（指向）数据，实现高级查找算法。

在无索引情况下，进行查询只能进行全表扫描，也就是从第一行开始扫描，直到最后一行，性能非常低。

优点：

* 提高数据检索效率，降低数据库 IO 成本（注意扫描次数与 IO 次数无关）
* 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。

缺点：

* 索引列需要占用空间
* 索引大大提高了查询效率，但是降低了更新表的速度

### 2.2 索引结构

#### 2.2.1 概述

MySQL 的索引是在存储引擎层面实现的，不同存储引擎有不同的索引结构，主要包括 B+ Tree 索引、Hash 索引、Full-text（全文索引）

InnoDB 支持的是 B+ Tree 索引

如果索引结构采用二叉树，即使是红黑树，也会由于每一个节点只能由两个子节点导致树的层级较深，从而导致检索速度慢，所以采用了 B+ Tree（在 B 树基础上优化）。

#### 2.2.2 B-Tree

B-Tree，B 树是一种多叉路衡查找树，相对于二叉树，B 树每个节点可以有多个分支，即多叉。 以一颗最大度数（max-degree）为 5 的b-tree为例，那这个 B 树每个节点最多存储 4 个key，5 个指针：

![3](..\assets\day02\3.png)

特点：

* 5阶的B树，每一个节点最多存储4个key，对应5个指针。
*  一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂。 
* 在B树中，非叶子节点和叶子节点都会存放数据。

#### 2.2.3 B+ Tree

在 B 树基础上进行优化：

* 所有的数据都会出现在叶子节点。 
* 叶子节点形成一个单向链表。 
* 非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。

![4](..\assets\day02\4.png)

MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，形成了双向链表，提高区间访问的性能，利于排序。

![5](..\assets\day02\5.png)

> 为什么 InnoDB 存储引擎要选用 B+ 树索引结构？
>
> * 相对于二叉树，层级更少，搜索效率高；
> * 对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，随着子节点数减少，要同样保存大量数据，只能增加树的高度，导致性能降低；
> * 相对Hash索引，B+tree支持范围匹配及排序操作；

#### 2.2.4 Hash

哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在 hash 表中。如果出现 Hash 冲突，通过链表来解决。

![6](..\assets\day02\6.png)

特点：

*  Hash索引只能用于对等比较(=，in)，不支持范围查询（between，>，< ，...） 
* 无法利用哈希索引完成排序操作 
* 查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索引

InnoDB 中具有自适应 hash 功能，hash索引是 InnoDB 存储引擎根据B+Tree索引在指定条件下自动构建的。

### 2.3 索引分类

| 分类     | 含义                                     | 特点                   | 关键字   |
| -------- | ---------------------------------------- | ---------------------- | -------- |
| 主键索引 | 针对于表中主键创建的索引                 | 默认自动创建，只有一个 | PRIMARY  |
| 唯一索引 | 避免同一表中某数据列的值重复             | 可以有多个             | UNIQUE   |
| 常规索引 | 快速定位特定数据                         | 可以有多个             |          |
| 全文索引 | 查找文本中的关键词，而不是比较索引中的值 | 可以有多个             | FULLTEXT |

#### 2.3.1 聚集索引与二级索引

根据索引的存储形式，又可以分为以下两种：

| 分类                        | 含义                                                       | 特点             |
| --------------------------- | ---------------------------------------------------------- | ---------------- |
| 聚集索引（Clustered Index） | 将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据 | 必须有，只有一个 |
| 二级索引（Secondary Index） | 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 | 可以存在多个     |

聚集索引选取规则：

* 有主键，选主键
* 没有主键，选第一个唯一索引
* 上面都没有，InnoDB 会自动生成 rowid 作为隐藏的聚集索引

<img src="..\assets\day02\7.png" alt="7" style="zoom:150%;" />

当执行 `selsect * from user where name = 'Arm';`时，具体的查找过程是这样的：

![8](..\assets\day02\8.png)

> 回表查询：在二级索引中查找主键值，然后再到聚集索引中根据主键值获取数据的方式，称为回表查询。

InnoDB 主键索引的 B+ tree 高度：

假设一行数据大小 1k，一页可以存储 16 行数据，InnoDB 指针占用 6 个字节，主键为 bigint 占用 8 个字节

高度为 2 时：

​	 n * 8 + (n+1) * 6 = 16 * 1024（一页默认大小） 这里的 n 是一个节点存储的主键个数，算出 n 约为 1170

​	1170 * 16 = 18736

也就是说，如果树高为 2，可以存储 18000 多条记录

高度为 3 时：

​	1171 * 1171 * 16 = 21939856

可以存储 2200w 多条记录

### 2.4 索引语法

```sql
# 创建索引
create [unique|fulltext] index index_name on table_name (
index_col_name, ...);

# 查看索引
show index from table_name;

# 删除索引
drop index index_name on table_name;

```

### 2.5 SQL 性能分析

#### 执行频率

```sql
-- session 是查看当前会话 ;
-- global 是查询全局数据 ;
SHOW  GLOBAL STATUS LIKE  'Com_______'; 
```

> 通过上述指令，我们可以查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据 库优化提供参考依据。 如果是以增删改为主，我们可以考虑不对其进行索引的优化。 如果是以 查询为主，那么就要考虑对数据库的索引进行优化了。

#### 慢查询日志

知道数据库以查询为主，又该怎么定位哪些查询语句需要优化？借助慢查询日志：

慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有 SQL语句的日志。MySQL的慢查询日志默认没有开启，需要到配置文件中配置如下信息：

```yaml
# 开启MySQL慢日志查询开关
slow_query_log=1

# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志
long_query_time=2
```

配置完毕后，需要重启 MySQL 服务。



#### explain 

EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。

```sql
# 直接在select语句之前加上关键字 explain / desc
EXPLAIN   SELECT   字段列表   FROM   表名   WHERE  条件 ;
```

Explain 执行计划中各个字段的含义:

| 字段          | 含义                                                         |
| ------------- | ------------------------------------------------------------ |
| id            | select查询的序列号，表示查询中执行select子句或者是操作表的顺序 (id相同，执行顺序从上到下；id不同，值越大，越先执行)。 |
| select_type   | 表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接 或者子查询）、PRIMARY（主查询，即子查询中外层的查询）、 UNION（UNION 中的第二个或者后面的查询语句）、 SUBQUERY（SELECT/WHERE之后包含了子查询）等 |
| type          | 表示连接类型，性能由好到差的连接类型为NULL、system、const、 eq_ref、ref、range、 index、all 。 |
| possible_keys | 显示可能应用在这张表上的索引，一个或多个。                   |
| key           | 实际使用的索引，如果为NULL，则没有使用索引。                 |
| key_len       | 表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好 。 |
| rows          | MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是准确的。 |
| filtered      | 表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好。 |

### 2.6 索引的使用

#### 最左前缀法则

如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始， 并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。

> 注意 ： 最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是 第一个字段)必须存在，与我们编写SQL时，条件编写的先后顺序无关，因为有优化器为我们排序。
>
> **为什么联合索引不遵循最左匹配原则就会失效？**
>
> 因为在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。
>
> 这种存储结构决定了：如果想使用联合索引中尽可能多的列，查询条件中的各个列必须是联合索引中从最左边开始连续的列。

联合索引中，出现范围查询（>, >=, <, <=, between），范围查询右侧的列索引失效。

> 我的理解：因为在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。范围查询到多个第一个数据会导致第二列的局部有序被破坏。

在实验中有一个现象：使用 >=, <= 范围查询时，key_len 与等值匹配时的相同，但是这并不代表索引没有失效。

> `key_len` 表示索引字段被使用的字节长度，但并不能判断是否为等值或范围查询；是否发生范围扫描应结合 `type`（ref / range）来判断。一旦出现范围条件，右侧列虽然仍计入 `key_len`，但只能用于过滤，不能继续缩小扫描区间。

### 2.7 索引失效

#### 左或者左右模糊匹配

当我们使用左或者左右模糊匹配的时候，即 like %xx 或者 like %xx% 这两种方式都会造成索引失效。但是，如果查询是 name 前缀为林的用户，就会走索引扫描，执行计划中的 type=range，key=index_name

> 我的理解：左模糊匹配，会导致不知道从哪个索引值开始比较，例如  `name like '%林' `的查询结果可以是陈林、张林...

#### 查询条件中对索引列进行运算

这个运算包括函数或表达式计算，即查询条件中对索引字段使用函数或查询条件中对索引进行表达式计算，会导致索引失效。

> 我的理解：索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然无法走索引
>
> 新特性：MySQL 8.0 之后，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引，也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据。

#### 索引列发生隐式类型转换

如果索引字段是字符串类型，但是在条件查询中，输入的参数是整型，这条语句会走全表扫描。

> 我的理解：整型转化为字符串是通过类型转化函数实现的，所以其实就是对索引列使用了函数

#### 联合索引不遵循最左匹配原则
#### where 子句中的or 

在 where 子句中，如果在 or 前的条件列是索引列，而在 OR 后的条件列不是索引列，就会造成索引失效。

> 我的理解：OR 的含义是两个只要满足一个即可，因此只有一个条件列表是索引列没有意义，只要有条件列不是索引列，就会走全表扫描。

#### 数据分布影响

如果 MySQL 评估使用索引比全表更慢，则不使用索引。 因为索引是用来索引少量数据的，如果通过索引查询返回大批量的数据，则还不如走全表扫描来的快，此时索引就会失效。

例如， is null 与 is not null 操作是否走索引的情况，如果字段大多数为 null，则 where 字段 is null，会走全表扫描，where 字段 is not null 会走索引（前提是该字段是索引列）；反之亦然。

### 2.8 SQL 提示

对于一个字段即存在联合索引，又存在单列索引，在查询时具体选择哪个索引呢？MySQL 会自动选择，也可以通过 sql 提示来指定。

```sql
# use index:  建议MySQL使用哪一个索引完成此次查询（仅仅是建议，mysql内部还会再次进
行评估）
select * from 表名 use index(索引名) where 字段 = value;

# ignore index ：忽略指定的索引
select * from 表名 ignore index(索引名) where 字段 = value;
# force index ： 强制使用索引。
select * from 表名 force index(索引名) where 字段 = value;
```

### 2.9 索引覆盖

索引覆盖是指查询使用了索引，并且需要返回的字段在该索引中已经全部找到（主键、联合索引字段），它是对回表查询的一种优化。

explain 中 extra 字段能够体现是否用到了索引覆盖：

| Extra                    | 含义                                                         |
| ------------------------ | ------------------------------------------------------------ |
| Using where; Using index | 查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据 |
| Using index condition    | 查找使用了索引，但是需要回表查询数据                         |

> 一张表, 有四个字段(id, username, password, status), 由于数据量大, 需要对以下SQL语句进行优化, 该如何进行才是最优方案：
>
> ​	select id,username,password from tb_user where username =  'itcast';
>
> 创建（username, password）的联合索引，避免回表查询

### 2.10 前缀索引

当字段类型为字符串（varchar，text，longtext 等）时，有时候需要索引很长的字符串，这会让索引变得很大，导致 B+ 树的 degree 下降甚至退化为二叉树，从而增加树的深度，影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。

```
create index  idx_xxxx on table_name(column(n)) ;
```

前缀的长度可以根据索引的选择性来决定 ，选择性是指不重复的索引值和数据表的记录总数的比值，选择性越高，查询效率越高，唯一索引的选择性是 1，性能最好。

> 我的理解：索引选择性就是一个区分度的意思，根据索引能唯一确定记录是最好的，如果根据索引值得到了一大堆记录，还要再进行筛选，索引的意义就不大了。

### 2.11 单列索引与联合索引

还是基于优化回表查询的知识点。

在 and 连接的两个字段都有各自的单列索引，但是 mysql 只会选择一个索引，然后走回表查询。

```sql
select id,phone,name from tb_user where phone = '11111' and name = '诸葛亮'
```

这种情形下，创建这两个字段（name、phone）的联合索引可以避免回表查询。



### 2.12 索引设计原则

* 针对于数据量较大，且查询比较频繁的表建立索引（`SHOW  GLOBAL STATUS LIKE  'Com_______';`）。
* 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索 引。 
* 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。 
* 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引（长度由索引选择性决定）。 
* 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。
*  要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。 
* 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含 NULL值时，它可以更好地确定哪个索引最有效地用于查询。

---------

## 3. SQL 优化

### 3.1 插入数据

如果我们需要一次性往数据库表中插入多条记录，可以从以下三个方面进行优化（主要是优化减少事务数量）。

```sql
insert  into  tb_test  values(1,'tom');
insert  into  tb_test  values(2,'cat');
insert  into  tb_test  values(3,'jerry');
......
```

* 批量插入数据

```sql
insert into tb_test values(1, 'tom'),(2,'cat'),(3,'jerry');
```

* 手动控制事务

```sql
start transaction;
insert  into  tb_test  values(1,'tom');
insert  into  tb_test  values(2,'cat');
insert  into  tb_test  values(3,'jerry');
commit;
```

如果一次性需要插入大批量数据(比如: 几百万的记录)，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令进行插入。

```sql
-- 客户端连接服务端时，加上参数  -–local-infile
mysql –-local-infile  -u  root  -p

-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关
set  global  local_infile = 1;

-- 执行load指令将准备好的数据，加载到表结构中
load  data  local  infile  '/root/sql1.log'  into  table  tb_user  fields terminated  by  ','  lines  terminated  by  '\n' ; 
```

> 注意：主键顺序插入性能高于乱序插入；

### 3.2 主键优化

主键顺序插入性能高于乱序，这主要由数据的组织方式决定

#### 数据组织方式

在 InnoDB 存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表 (index organized table IOT)。

![5](..\assets\day02\5.png)

![2](..\assets\day02\2.png)

在 InnoDB 引擎中，数据行是记录在逻辑结构 page 页中的，而每一个页的大小是固定的，默认16K。 那也就意味着， 一个页中所存储的行也是有限的，如果插入的数据行 row 在该页存储不小，将会存储到下一个页中，页与页之间会通过指针连接。 

#### 页分裂

页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据(如果一行数据过大，会行溢出)，根据主键排列。

**主键顺序插入的情况下：**

1. 从磁盘中申请页，主键顺序插入

![9](..\assets\day02\9.png)

2. 在第一页写满后，再写入第二个页，页与页之间会通过指针连接

![10](..\assets\day02\10.png)

![10](..\assets\day02\11.png)

3. 以此类推，第二页写满，再往第三页写

![10](..\assets\day02\12.png)

**主键乱序插入的情况下：**
1. 加入1#，2#页都已经写满了，存放了如图所示的数据

![10](..\assets\day02\13.png)

2. 此时再插入 id 为 50 的记录，会发生页分裂

因为，索引结构的叶子节点是有顺序的，按照顺序，50 应该存储在 47 之后。

![10](..\assets\day02\14.png)

但是47所在的1#页，已经写满了，存储不了50对应的数据了。 那么此时会开辟一个新的页 3#。但是并不会直接将 50 存入 3#页，而是会将 1# 页后一半的数据，移动到 3# 页，然后再插入 50

![10](..\assets\day02\15.png)

为了保持数据顺序，此时需要重新设置链表指针

![10](..\assets\day02\16.png)

所以，如果乱序插入主键，有可能会导致页分裂：数据分半、数据插入、链表排序。这是比较耗费性能的操作。

#### 页合并

目前表中已有数据的索引结构(叶子节点)如下：

![10](..\assets\day02\17.png)

当删除已有数据时，实际上记录并没有被物理伤处，只是被标记（flaged）为删除，并且它的空间允许被其他记录声明使用。

![10](..\assets\day02\18.png)

当页中删除记录达到 MERGE_THRESHOLD （默认为页的 50%），InnoDB 会开始检查前后页是否可以进行合并以优化空间。

![10](..\assets\day02\19.png)

> MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或者创建索引时指定。


#### 索引设计原则
* 满足业务需求的情况下，尽量降低主键的长度。
* 插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键。
* 尽量不要使用UUID做主键或者是其他自然主键，如身份证号。
* 业务操作时，避免对主键的修改。

### 3.3 order by 优化

MySQL 的排序有两种方式：

* Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort 
buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都是 FileSort 排序。

* Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要
额外排序，操作效率高。

排序优化的目标就是将排序方式优化为 Using index

> 排序时,也需要满足最左前缀法则,否则也会出现 filesort。

对联合索引字段进行排序时，一个升序一个降序，也会退化为 filesort，解决方法就是建立联合索引时，指定一个升序一个降序
```sql
create  index  idx_user_age_phone_ad  on  tb_user(age asc ,phone desc);

```

**小结**
order by优化原则：
* 根据排序字段建立合适的索引，多字段排序时，也要遵循最左前缀法则。
* 尽量使用覆盖索引。
* 多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）。
* 如果不可避免的出现 filesort，大数据量排序时，可以适当增大排序缓冲区大小 
sort_buffer_size(默认256k)。

### 3.4 group by 优化

在分组操作时，可以通过索引来提高效率，同时索引的使用也是满足最左前缀法则的。

### 3.5 limit 优化

在数据量比较大时，如果进行limit分页查询，在查询时，越往后，分页查询效率越低。

因为，当在进行分页查询时，如果执行 limit 2000000,10 ，此时需要MySQL排序前2000010 记
录，仅仅返回 2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大 。

优化思路: 一般分页查询时，可以通过覆盖索引加子查询形式进行优化。

```sql
explain   select  *  from  tb_sku  t  ,  (select  id  from  tb_sku order  by  id limit  2000000,10)  a  where t.id  =  a.id;
```

### 3.6 count 优化

如果数据量很大，在执行count操作时，是非常耗时的。

* MyISAM： 把一个表的总行数存在了磁盘上，因此执行 count( * ) 的时候会直接返回这个
数，效率很高； 但是如果是带条件的count，MyISAM也慢。
* InnoDB：它执行 count( * ) 的时候，需要把数据一行一行从引擎里面读出来，然后累积计数。

如果说要大幅度提升 InnoDB表的count效率，主要的优化思路：自己计数(可以借助于redis这样的数据库进行,但是如果是带条件的count又比较麻烦了)。

**count 用法：**

count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 
NULL，累计值就加 1，否则不加，最后返回累计值。

| 用法         | 含义                                                         |
| ------------ | ------------------------------------------------------------ |
| count (主键) | InnoDB 引擎会遍历整张表，把每一行的 主键id 值都取出来，返回给服务层。 服务层拿到主键后，直接按行进行累加(主键不可能为null) |
| count (字段) | 没有not null 约束 : InnoDB 引擎会遍历整张表把每一行的字段值都取出 来，返回给服务层，服务层判断是否为null，不为null，计数累加。 有not null 约束：InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加。 |
| count (数字) | InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字“1” 进去，直接按行进行累加。 |
| count (*)    | InnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加。 |

> 理解了 count 的用法不难按照效率排序 count (字段) < count (主键) < count (1) = count (*)

### 3.7 update 优化

update 语句的优化在于防止索引失效，否则会导致 update 语句加上表锁，这在开启多个事务时，会大大降低性能。

> 因为 InnoDB 的行锁是针对索引加的锁，不是针对记录加锁，所以索引失效后，行锁就会升级为表锁

### 4 总结

今天主要学习了索引与 SQL 优化，这也是MySQL中的重点，下面梳理一下知识点：

1. MySQL 的优势在于存储引擎插件化，可以根据需求定制化表的存储引擎，而 InnoDB 相较于 MyISAM 的优势主要在于行级锁、支持外键、事务
2. 索引结构的选择：二叉树高度太高，B 树的节点即含数据又含索引，会导致度数下降，退化为二叉树，hash 不支持范围查询，所以选择了 B+树
3. 针对 DQL 的优化本质就是利用索引查询，索引覆盖，注意索引中的值是有序的，利用这个可以优化 order by
4. count 的四个用法的不同在于扫描记录是否取值，取值了是否需要比较，还是说直接按行累加
5. 针对 DML 的优化：批量插入减少事务、UPDATE 用上索引避免行锁升级为表锁
6. 谈到优化当然优化前需要用到 SQL 分析，这里 explain 最重要，要会用，要懂每个字段的意思。

